<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>使用工厂化方法创建对象</title>
    <script>
        // 1. 批量创建对象
        function createObject(name, age, address) {
            var obj = {
                name: name,
                age: age,
                address: address,
                sayAddress: function () {
                    console.log(this.address);
                }
            }
            return obj;
        }
        var obj1 = createObject('xiaosu', 19, 'HuBei');
        var obj2 = createObject('xiaoke', 16, 'GuangDong')
        obj1.sayAddress(); // 'HuBei'
        obj2.sayAddress(); // 'GuangDong'

        /*
        2. 自定义构造函数批量创建对象
        执行流程：
            1. 立即创建一个新的对象
            2. 将新建的对象设置为函数中的 this
            3. 逐行执行函数中的代码
            4. 将新建的对象作为返回值返回
        
        创建一个 Person 构造函数
            - 在 Person 构造函数中为每一个对象都添加了一个 sayName 方法
                目前我们的方法是在构造函数内部创建的
                也就是构造函数每执行一次就会创建一个新的 sayName 方法
            - 所有实例化对象的 sayName 方法都是唯一的
                这样就导致了构造函数执行一次就会创建一个新的方法
                执行 10000 次就会创建 10000 个方法，
        */
        function Dog(name, age) {
            this.name = name;
            this.age = age;
            this.sayName = function () {
                console.log(this.name);
            }
        }

        var dog1 = new Dog('Su', 3); // 立即创建一个新的对象 dog1，并且将 dog1 设置为 this
        console.log(dog1); // Dog {name: "Su", age: 3}

        /*
        我们将通过一个构造函数创建的对象，称为该类的实例
        使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类
            使用 instanceof 可以检查一个对象是否是一个类的实例
            语法：对象 instanceof 构造函数
        */
        console.log(dog1 instanceof Dog); // true

        // 所有的对象都是 Object 的后代，所以所有的对象和 Object 比较返回都是 true
        console.log(dog1 instanceof Object); // true

        // 3. 构造函数优化 -- 将 sayName 方法在全局作用域中定义
        // 优化：实例化对象时不用每次都创建 sayName 函数
        // 缺点：将函数定义在全局作用域污染了全局作用域的命名空间而且极不安全
        function Person(name, age) {
            this.name = name;
            this.age = age;
            this.sayName = fun
        }

        function fun() {
            console.log(this.name);
        }

        var person1 = new Person('xiaosu', 19);
        person1.sayName(); // 'xiaosu'

        // 4. 使用原型对象继续优化
        function Fish(name, age){
            this.name = name;
            this.age = age
        }

        // 向原型对象中添加 sayName 属性
        Fish.prototype.sayName = function(){
            console.log(this.name);
        }

        fish = new Fish('li yu', 2);

        fish.sayName(); // 'li yu'
    </script>
</head>

<body>
</body>

</html>